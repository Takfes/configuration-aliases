#!/bin/bash

# Check if git is installed
command -v git >/dev/null 2>&1 || {
  echo >&2 "git is not installed. Skipping git configuration."
  return
}

# ==============================================================
# > basic git operations
# ==============================================================

alias gs="git status"
alias gca="git commit --amend"
alias gmc="git diff --name-only --diff-filter=U"

# ==============================================================
# > remote operations
# ==============================================================

alias gps="git push"
alias gpl="git pull"
alias gfa="git fetch --all"

# ==============================================================
# > branch operations
# ==============================================================

# Move Branches
alias gsw="git switch"
alias gf='git checkout $(git branch | fzf)' # checkout to branch using fzf
alias gcb="git checkout -b"                 # same as "git switch -c"

# List branches
alias gb='git branch'
alias gba='git branch -a'     # list all branches
alias gbl='git branch --list' # list local branches
alias gbr='git branch -r'     # list remote branches - from latest fetch
alias gblr="git ls-remote"    # list remote branches - fetch again
alias gblp="git ls-remote --heads origin | awk '{print $2}' | sed 's#refs/heads/##'"

# Manipulate branches
alias gbn='git branch -m'             # rename the current branch
alias gbu='git branch -u'             # set upstream of the current branch
alias gbd='git branch -d'             # delete the current branch
alias gbD='git branch -D'             # delete the current branch even though not merged
alias gbdr='git push origin --delete' # delete remote branch

# ==============================================================
# > stash operations
# ==============================================================

alias gt="git stash"
alias gtl="git stash list"
alias gtc="git stash clear"
alias gta="git stash apply" # git stash apply stash@{2}
alias gtp="git stash pop"   # git stash pop stash@{2}
alias gtd="git stash drop"  # git stash drop stash@{2}

# ==============================================================
# > log operations
# ==============================================================

alias gla="git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit -- | nl -v 0"
alias glb="git log --oneline --decorate --graph"
alias glc="git log --decorate --graph --oneline --all"
alias gld="git log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s' --date=short --decorate --graph"

# ==============================================================
# > git configuration
# ==============================================================

alias guu='git config --global user.name && git config --global user.email'
alias guc='git config --get credential.helper'
alias gul='git config -l'
# alias gconfn='git config --global user.name'
# alias gconfe='git config --global user.email'

# ==============================================================
# > git diff operations
# ==============================================================

alias gdf="git diff"                             # shows unstaged changes
alias gds="git diff --staged"                    # shows staged changes same as "git diff --cached"
alias gdh="git diff HEAD"                        # shows everything that has changed since HEAD
alias gdm="git diff --name-only --diff-filter=U" # highlight files with merge conflicts

# alias gd="git diff --stat --diff-filter=M"
# after the diff |-> use file to narrow the results down to file(s)
# after the diff |-> use : branch1..branch2 to compare branches | or commit hashes commitHash1..commitHash2

# ==============================================================
# > other git operations
# ==============================================================

alias grmc="git rm -r --cached"                    # Untrack Files without deleting them
alias gfp="git fetch --all --prune"                # fetches all branches from all remotes & removes any remote-tracking branches which no longer exist on the remote
alias gx="ign = ls-files -o -i --exclude-standard" # show ignored files by git

# ==============================================================
# > git functions
# ==============================================================

# Create local branch from remote branch
function gbt() {
  git checkout -b $1 origin/$1
  # git checkout -b <branch> origin/<branch> # create a local branch from a remote branch
  # git checkout -t origin/branch
  # git switch -c <branch> origin/<branch>
}

# Interactive branch switcher: lists all local branches except current, lets user select one to switch to
function bm() {
  # get current branch
  current_branch=$(git branch --show-current)
  # get all local branches except for the current
  local_branches=$(git branch | sed 's/\*//g' | grep -v "$current_branch")
  echo "Please select a branch:"
  i=1
  for branch_name in $local_branches; do
    #   echo "$i) $branch_name"
    echo "$i) $(cds $branch_name)"
    ((i++))
  done
  # read the user's input..
  echo "Enter branch number (0 to exit): "
  read selected_branch_number
  # exit function if the user passes 0
  if [ "$selected_branch_number" -eq 0 ]; then
    echo "Exiting..."
    return
  fi
  # store the corresponding branch name in a variable named selected_branch
  selected_branch=$(echo "$local_branches" | awk -v n="$selected_branch_number" 'NR==n{print $0;exit}')
  # switch to the selected branch
  git switch $selected_branch
}

# function to list all available branches and delete the selected one
function bmd() {
  # get current branch
  current_branch=$(git branch --show-current)
  # get all local branches except for the current
  local_branches=$(git branch | sed 's/\*//g' | grep -v "$current_branch")

  echo "Please select a branch:"
  i=1
  for branch_name in $local_branches; do
    #   echo "$i) $branch_name"
    echo "$i) $(cds $branch_name)"
    ((i++))
  done
  # read the user's input..
  echo "Enter branch number (0 to exit): "
  read selected_branch_number
  # exit function if the user passes 0
  if [ "$selected_branch_number" -eq 0 ]; then
    echo "Exiting..."
    return
  fi
  # store the corresponding branch name in a variable named selected_branch
  selected_branch=$(echo "$local_branches" | awk -v n="$selected_branch_number" 'NR==n{print $0;exit}')
  # switch to the selected branch
  git branch -d $selected_branch
}

# list remote branches and checkout to local branch
function grems() {
  # read all remote branches, remove the "origin/"  part from their name and sort them in alphabetical order
  # remote_branch_names=$(git branch -r | awk '{print $1}' | cut -c 8- | grep -v HEAD | sort)
  remote_branch_names=$(git ls-remote --heads origin | awk '{print $2}' | sed 's#refs/heads/##')
  # read all local branches
  local_branch_names=$(git for-each-ref --format='%(refname:short)' refs/heads/)
  # find the remote branches with no local counterpart
  untracked_branch_names=$(comm -13 <(echo "$local_branch_names" | tr ' ' '\n' | sort) <(echo "$remote_branch_names" | tr ' ' '\n' | sort) | tr '\n' ' ')
  # iterate over the untracked_branch_names
  echo "Please select a branch:"
  i=1
  for branch_name in $untracked_branch_names; do
    #   echo "$i) $branch_name"
    echo "$i) $(cds $branch_name)"
    ((i++))
  done
  # read the user's input..
  echo "Enter branch number (0 to exit): "
  read selected_branch_number
  # exit function if the user passes 0
  if [ "$selected_branch_number" -eq 0 ]; then
    echo "Exiting..."
    return
  fi
  selected_branch=$(echo "$untracked_branch_names" | tr ' ' '\n' | sed -n "${selected_branch_number}p")
  git branch --track $selected_branch origin/$selected_branch
}

# ==============================================================
# > helper functions
# ==============================================================

# Prints a given path with each directory colored differently for enhanced readability in the terminal.
function cds() {
  path="$1"
  IFS='/' read -ra parts <<<"$path"
  # 31-Red # 32-Green # 33-Yellow # 34-Blue # 35-Magenta # 36-Cyan # 37-White
  colors=(31 32 33 34 35 36 37)
  result=""
  for i in "${!parts[@]}"; do
    part="${parts[$i]}"
    color_index=$((i % ${#colors[@]}))
    color_code="${colors[$color_index]}"
    result+="\033[0;${color_code}m${part}\033[0m"
    if ((i < ${#parts[@]} - 1)); then
      result+="/"
    fi
  done
  echo -e "$result"
}

# function to toggle between users
function gut() {
  echo "Current user: $(git config --global user.name), $(git config --global user.email)"
  echo "Select a git user configuration:"
  echo "1. takis/titan"
  echo "2. takis/personal"
  read -p "Enter a number (1-2): " user_choice
  case $user_choice in
  1)
    git config --global user.name "pfessas"
    git config --global user.email "p.fessas@titancement.com"
    echo "Switched to takis/titan configuration"
    ;;
  2)
    git config --global user.name "Takfes"
    git config --global user.email "takis_a29@hotmail.com"
    echo "Switched to takis/personal configuration"
    ;;
  *)
    echo "Invalid choice. Please enter a number between 1 and 2."
    ;;
  esac
}

# ==============================================================
# > git time travel / undo operations
# ==============================================================

# alias gcu="git checkout --"      # discard changes -on selected files- back to HEAD | "git checkout -- <file1> <file2>" | same as "git checkout HEAD <filename(s)>" & "git restore <filename(s)>"
# alias gcr="git restore --source" # discard changes -on selected files- up to reference point | "git restore --source <HEADreference [HEAD~3] or commitHash> <filename"
# alias grs="git reset"            # --soft or --hard to retain or not changes |-> same as "git restore --staged <filename>" | if used with <commit hash> or HEAD~2 goes back to commit and retains changes in workdir
# alias grv="git revert"           # <commit-hash-to-undo> creates a new commit that undoes the selected one - use revert when working with team
# alias gri="git rebase -i HEAD~"  # git rebase (inplace - i.e. replaying the history of the current branch itself
# alias grf="git reflog show"      # git reflog show master -> pick the hash and then -> git reset --hard master@{1} or <commitHash

# CHECKOUT : git checkout <commit-hash>                          # go to a specific commit
# CHECKOUT : git checkout HEAD~2                                 # go back 2 commits
# CHECKOUT : git checkout HEAD <file>                            # discard changes in a file
# RESTORE : git restore <file>                                  # discard changes in a file
# RESTORE : git restore --source=<commit or HEAD~#> <file>      # Restore a file to a specific commit
# RESTORE : git restore --staged <file>                         # Unstage a file
# RESET : git reset <--hard or --soft> <commit-hash or HEAD~> # go back to a specific commit and retain or not changes
# REVERT : git revert <commit-hash>                            # Undo a specific commit
# REVERT : git revert --no-commit HEAD~3..                     # Undo last 3 commits without committing them

# RESTORE : git restore <file>                   # Discard changes in a file
# RESTORE : git restore --staged <file>          # Unstage a file
# RESTORE : git restore --source=<commit> <file> # Restore a file to a specific commit
# RESTORE : git restore --worktree <file>        # Discard unstaged changes in the working tree for a file
# RESTORE : git restore -W <file>                # Restore a file ignored by "assume unchanged" or "skip worktree" bits
# RESET : git reset # Unstage changes
# RESET : git reset HEAD~1            # Undo last commit and keep changes
# RESET : git reset --hard HEAD~1     # Discard last commit and changes
# RESET : git reset --soft HEAD~1     # Undo last commit but leave changes staged
# RESET : git reset --merge <commit>  # Reset and update files in the working tree that are different between <commit> and HEAD
# RESET : git reset --keep <commit>   # Reset index entries and updates files in the working tree
# REVERT : git revert HEAD              # Undo the last commit
# REVERT : git revert <commit-hash>     # Undo a specific commit
# REVERT : git revert -n <commit-hash>  # Undo a specific commit without committing it
# REVERT : git revert --continue        # Continue the revert process after resolving conflicts
# REVERT : git revert --abort           # Cancel the revert process and return to the pre-revert state

# ==============================================================
